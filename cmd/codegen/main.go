package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
)

const (
	pkgName         = "elevenlabs"
	receiverType    = "Client"
	defaultReceiver = "getDefaultClient()"
	genFileName     = "shorthand.go"
	genFileTemplate = `// Code generated by {{.GeneratorPath}}; DO NOT EDIT.
// Run 'go generate' after adding new methods with a '{{.ReceiverType}}' pointer receiver.

package elevenlabs
{{range .Functions}}
func {{.FuncIdent}}{{.FuncParams}}{{.FuncResults}} {
	{{if .FuncResults}}return {{end}}{{.MethodReceiver}}.{{.FuncIdent}}{{.FuncArgs}}
}
{{end}}`
)

var sourceFiles []string = []string{"client.go", "models.go", "errors.go"}

type proxyFuncFile struct {
	GeneratorPath string
	ReceiverType  string
	Functions     []proxyFunc
}

type proxyFunc struct {
	FuncIdent, FuncParams, FuncArgs, FuncResults, MethodReceiver string
}

func main() {
	b := bytes.Buffer{}
	pkg, err := parsePackage(pkgName, ".", []string{genFileName})
	if err != nil {
		log.Fatal(err)
	}
	n, err := generate(&b, pkg.Files)
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(genFileName, b.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Wrote %d functions to %s\n", n, genFileName)
}

func generate(w io.Writer, pkgFiles map[string]*ast.File) (int, error) {
	var total int
	g, err := getCurrentRelPath()
	if err != nil {
		return 0, err
	}
	sFile := proxyFuncFile{
		GeneratorPath: g,
		ReceiverType:  receiverType,
	}
	for _, pf := range pkgFiles {
		methods := ptrRcvMethods(pf, receiverType)
		for _, m := range methods {
			sFile.Functions = append(sFile.Functions, proxyFunc{
				FuncIdent:      m.Name.Name,
				FuncParams:     genTypedParams(m.Type.Params),
				FuncArgs:       genFuncArgs(m.Type.Params),
				FuncResults:    genFuncReturnTypes(m.Type.Results),
				MethodReceiver: defaultReceiver,
			})
		}
		total += len(methods)
	}
	t := template.Must(template.New("").Parse(genFileTemplate))
	if err := t.Execute(w, sFile); err != nil {
		return 0, err
	}

	return total, nil
}

func parsePackage(pkgName string, path string, excludeFiles []string) (*ast.Package, error) {
	excludeFunc := func(fi fs.FileInfo) bool {
		for _, f := range excludeFiles {
			if fi.Name() == f {
				return false
			}
		}
		return true
	}
	pkgs, err := parser.ParseDir(token.NewFileSet(), path, excludeFunc, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to parse directory %q: %w", path, err)
	}
	pkg, ok := pkgs[pkgName]
	if !ok {
		return nil, fmt.Errorf("package %s not found in directory", pkgName)
	}
	return pkg, nil
}

func ptrRcvMethods(f *ast.File, receiverTypeStr string) []*ast.FuncDecl {
	methodDecls := []*ast.FuncDecl{}
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok &&
			funcDecl.Name.IsExported() &&
			funcDecl.Recv != nil && len(funcDecl.Recv.List) > 0 { //If declaration is a exported function that has a receiver (i.e. method)
			if ptrRecvExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr); ok &&
				fmt.Sprint(ptrRecvExpr.X) == receiverTypeStr {
				methodDecls = append(methodDecls, funcDecl)
			}
		}
	}
	return methodDecls
}

func genTypedParams(fl *ast.FieldList) string {
	if fl.List == nil {
		return "()"
	}
	params := make([]string, len(fl.List))
	for i, f := range fl.List {
		names := make([]string, len(f.Names))
		for j, fn := range f.Names {
			names[j] = fn.Name
		}
		paramNames := strings.Join(names, ", ")
		if paramNames != "" {
			paramNames += " "
		}
		params[i] = paramNames + exprToString(f.Type)
	}
	return fmt.Sprintf("(%s)", strings.Join(params, ", "))
}

func genFuncArgs(fl *ast.FieldList) string {
	if fl.List == nil {
		return "()"
	}
	args := make([]string, len(fl.List))
	for i, p := range fl.List {
		names := make([]string, len(p.Names))
		for j, pName := range p.Names {
			names[j] = pName.Name
		}
		paramNames := strings.Join(names, ", ")
		switch p.Type.(type) {
		case *ast.Ellipsis:
			args[i] = fmt.Sprintf("%s...", paramNames)
		default:
			args[i] = paramNames
		}
	}
	return fmt.Sprintf("(%s)", strings.Join(args, ", "))
}

func genFuncReturnTypes(fl *ast.FieldList) string {
	if fl == nil || fl.List == nil {
		return ""
	}
	ret := make([]string, len(fl.List))
	for i, f := range fl.List {
		ret[i] = exprToString(f.Type)
	}
	if len(ret) == 1 {
		return " " + ret[0]
	}
	return fmt.Sprintf(" (%s)", strings.Join(ret, ", "))
}

func exprToString(expr ast.Expr) string {
	switch fieldType := expr.(type) {
	case *ast.ArrayType:
		return fmt.Sprintf("[]%s", exprToString(fieldType.Elt))
	case *ast.Ellipsis:
		return fmt.Sprintf("...%s", exprToString(fieldType.Elt))
	case *ast.StarExpr:
		return fmt.Sprintf("*%s", exprToString(fieldType.X))
	case *ast.FuncType:
		return fmt.Sprintf("func%s%s", genTypedParams(fieldType.Params), genFuncReturnTypes(fieldType.Results))
	}
	return fmt.Sprintf("%s", expr)
}

func getCurrentRelPath() (string, error) {
	var path string
	_, filename, _, ok := runtime.Caller(0)
	if ok {
		currentDir, err := os.Getwd()
		if err != nil {
			return "", err
		}
		path, err = filepath.Rel(currentDir, filename)
		if err != nil {
			return "", err
		}
	}
	return path, nil
}

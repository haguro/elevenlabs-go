package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	pkgName     = "elevenlabs"
	genFileName = "shorthand.go"
)

var sourceFiles []string = []string{"client.go", "models.go", "errors.go"}

func main() {
	b := bytes.Buffer{}
	n, err := generate(&b, []string{genFileName})
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(genFileName, b.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Wrote %d functions to %s\n", n, genFileName)
}

func generate(w io.Writer, excludeFiles []string) (int, error) {
	var total int
	generator, err := getCurrentRelPath()
	if err != nil {
		return 0, err
	}
	pkg, _ := parsePackage(pkgName, ".", excludeFiles)
	fmt.Fprintf(w, "// Code generated by %q. run `go generate` when adding new `Client` methods; DO NOT EDIT.\n\n", generator)
	fmt.Fprintf(w, "package elevenlabs\n")
	for _, f := range pkg.Files {
		methods := exportedMethods(f, "Client")
		for _, m := range methods {
			paramStr := strings.Join(genTypedParams(m), ", ")
			argStr := strings.Join(genFuncArgs(m), ", ")
			returns := genFuncReturns(m)
			retStr := strings.Join(returns, ", ")
			if len(returns) > 1 {
				retStr = fmt.Sprintf("(%s)", retStr)
			}

			fmt.Fprintf(w, "\nfunc %s(%s) %s {\n", m.Name.Name, paramStr, retStr)
			fmt.Fprintf(w, "\treturn getDefaultClient().%s(%s)\n", m.Name.Name, argStr)
			fmt.Fprintf(w, "}\n")
		}
		total += len(methods)
	}

	return total, nil
}

func parsePackage(pkgName string, path string, excludeFiles []string) (*ast.Package, error) {
	excludeFunc := func(fi fs.FileInfo) bool {
		for _, f := range excludeFiles {
			if fi.Name() == f {
				return false
			}
		}
		return true
	}
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, path, excludeFunc, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to parse directory %q: %w", path, err)
	}
	pkg, ok := pkgs[pkgName]
	if !ok {
		return nil, fmt.Errorf("package %s not found in directory", pkgName)
	}
	return pkg, nil
}

func exportedMethods(f *ast.File, receiverTypeStr string) []*ast.FuncDecl {
	methodDecls := []*ast.FuncDecl{}
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok &&
			funcDecl.Name.IsExported() &&
			funcDecl.Recv != nil && len(funcDecl.Recv.List) > 0 { //If declaration is a exported function that has a receiver (i.e. method)
			if ptrRecvExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr); ok &&
				fmt.Sprint(ptrRecvExpr.X) == receiverTypeStr {
				methodDecls = append(methodDecls, funcDecl)
			}
		}
	}
	return methodDecls
}

func genTypedParams(f *ast.FuncDecl) []string {
	params := make([]string, len(f.Type.Params.List))
	for i, p := range f.Type.Params.List {
		names := make([]string, len(p.Names))
		for i, pName := range p.Names {
			names[i] = pName.Name
		}
		paramNames := strings.Join(names, ", ")
		switch paramType := p.Type.(type) {
		case *ast.Ellipsis:
			params[i] = fmt.Sprintf("%s ...%s", paramNames, paramType.Elt)
		case *ast.StarExpr:
			params[i] = fmt.Sprintf("%s *%s", paramNames, paramType.X)
		default:
			params[i] = fmt.Sprintf("%s %s", paramNames, paramType)
		}
	}
	return params
}

func genFuncArgs(f *ast.FuncDecl) []string {
	args := make([]string, len(f.Type.Params.List))
	for i, p := range f.Type.Params.List {
		names := make([]string, len(p.Names))
		for j, pName := range p.Names {
			names[j] = pName.Name
		}
		paramNames := strings.Join(names, ", ")
		switch p.Type.(type) {
		case *ast.Ellipsis:
			args[i] = fmt.Sprintf("%s...", paramNames)
		case *ast.StarExpr:
			args[i] = paramNames
		default:
			args[i] = paramNames
		}
	}
	return args
}

func genFuncReturns(f *ast.FuncDecl) []string {
	ret := make([]string, len(f.Type.Results.List))
	for i, r := range f.Type.Results.List {
		switch paramType := r.Type.(type) {
		case *ast.ArrayType:
			ret[i] = fmt.Sprintf("[]%s", paramType.Elt)
		case *ast.StarExpr:
			ret[i] = fmt.Sprintf("*%s", paramType.X)
		default:
			ret[i] = fmt.Sprintf("%s", paramType)
		}
	}
	return ret
}

func getCurrentRelPath() (string, error) {
	path := ""
	_, filename, _, ok := runtime.Caller(0)
	if ok {
		currentDir, err := os.Getwd()
		if err != nil {
			return "", err
		}
		path, err = filepath.Rel(currentDir, filename)
		if err != nil {
			return "", err
		}
	}
	return path, nil
}
